# 轻量级多路复用架构设计
### **什么是会话池（Session Pool）？**

**类比生活中的例子**：

- 传统做法（无池化）：
  - 用户A需要骑车 → 购买新车 → 使用后丢弃 ❌
  - **问题**：每次开销极大，资源浪费严重。
- 池化做法（会话池）：
  - 用户A需要骑车 → 从停车点取车 → 使用后归还 ✅
  - 用户B需要骑车 → 复用用户A归还的车 ✅
    ​**会话池本质**​：网络连接的“共享单车系统”，实现连接复用。

**为什么要设计会话池**？
1.创建会话的真实成本（单次操作）:
  - TCP 三次握手：50-200ms
  - TLS 握手：100-300ms
  - 版本协商：50-100ms
  - 内存分配：2MB左右
  - 线程创建：10-50ms
  - 总计：210-650ms + 2MB 内存

2.频繁创建和销毁问题
```objc
消息1: 创建会话 → 发送 → 销毁（耗时500ms ）  
消息2: 创建会话 → 发送 → 销毁（耗时500ms ）  
消息3: 创建会话 → 发送 → 销毁（耗时500ms ）  
→ 总耗时：1500ms ❌
```

3.池化后的效果

```objc
消息1: 创建会话 → 发送 → 放回池子（耗时500ms）  
消息2: 从池子取用 → 发送 → 放回池子（耗时10ms）  
消息3: 从池子取用 → 发送 → 放回池子（耗时10ms）  
→ 总耗时：520ms（节省80%+）
```

### 会话池架构设计

1.基础概念图
```
┌─────────────────────────────────────────────────────┐  
│                  TJPSessionPool                     │  
│  ┌─────────────────┐       ┌─────────────────┐      │  
│  │可用池 (Available)│       │  活跃池 (Active) │      │  
│  │                 │       │                 │      │  
│  │ [Chat-1] 💤    │       │ [Chat-2] 🟢     │      │  
│  │ [Chat-3] 💤    │       │ [Media-1] 🟢    │      │  
│  │ [Media-2] 💤   │       │ [Signal-1] 🟢   │      │  
│  └─────────────────┘       └─────────────────┘      │  
│ 流向：使用 Available → Active；释放 Active → Available │  
└─────────────────────────────────────────────────────┘  
💤 = 空闲状态 | 🟢 = 活跃状态  
```
2.数据流向图
```
[应用] 
   ↓ 发送消息
[TJPIMClient] ← 自动路由 (文本→聊天, 媒体→媒体)
   ↓ 获取会话
[TJPNetworkCoordinator] ← 全局协调
   ↓ 请求会话
[TJPLightweightSessionPool] ← 会话复用/创建
   ↓ 复用/新建
[TJPConcreteSession] ← 具体连接处理
   ↓ 连接管理
[TJPConnectionManager] ← 底层连接
   ↓ 数据传输
[GCDAsyncSocket] ← 系统Socket
```

3.分类管理设计
``` Objc
// 按会话类型存储：  
sessionPool = {  
    TJPSessionTypeChat: {  
        available: [session1, session3], // 空闲聊天会话  
        active: [session2]               // 活跃聊天会话  
    },  
    TJPSessionTypeMedia: {  
        available: [session4],           // 空闲媒体会话  
        active: [session5, session6]     // 活跃媒体会话  
    },  
    TJPSessionTypeSignaling: {  
        available: [],                   // 无空闲信令会话  
        active: [session7]               // 活跃信令会话  
    }  
}
```
### 工作流程详解
1.检查目标类型 available 池，若有空闲会话：取出 -> 移入active ->返回
2.若 active 数量 >= 最大限制，返回空或者等待空闲
3.创建新会话 -> 移入 active -> 返回

### 释放流程详解
1.从 active 池移除
2.若会话健康：重置状态 -> 移入 available 池
3.若会话异常直接销毁
4.记录释放时间

### 智能清理流程
- 遍历所有 available 池中的会话
- 若空闲时间 > 5分钟，销毁会话并从池中移除

### 多路复用核心思想
会话Session自治 + 中心调度控制
- 会话自治：每个会话独立管理状态、心跳、重连等
- 中心调度：coordinator仅负责会话生命周期管理及调度

### 配置参数说明
- 聊天应用：低频率消息，2个会话支持基本可覆盖
- 游戏应用：高频实时数据，需要更多会话支持突发流量
- 文件上传：单线程操作，1个会话避免资源竞争

### 关键设计
- 基于待确认消息的负载均衡，非复杂算法，一般中小型应用可覆盖
- 固定大小会话池，每个类型最多3个
- 定期清理空闲会话，避免资源囤积
- 按消息类型路由

### 组件职责划分
应用层

业务逻辑处理
用户界面交互
消息内容构建

TJPIMClient (门面层)
职责:
- 统一API接口
- 消息类型路由
- 多通道管理
- 连接状态监控

特点:
- 隐藏底层复杂性
- 支持多种会话类型
- 自动路由机制
TJPNetworkCoordinator (协调层)
职责:
- 全局网络状态管理
- 会话生命周期协调
- 重连策略执行
- 代理关系管理

特点:
- 单例模式
- 网络状态监听
- 会话池集成
TJPLightweightSessionPool (池化层)
职责:
- 会话对象复用
- 内存使用优化
- 自动清理机制
- 预热和预创建

特点:
- 提升性能
- 降低内存碎片
- 智能健康检查
- 容量自动管理
TJPConcreteSession (会话层)
职责:
- 单一连接管理
- 协议实现
- 状态机驱动
- 消息可靠性

特点:
- 状态机模式
- 心跳检测
- 自动重传
- 协议版本协商
TJPConnectionManager (连接层)
职责:
- Socket连接管理
- 超时控制
- TLS支持
- 连接事件通知

特点:
- 连接抽象
- 安全传输
- 异常处理
GCDAsyncSocket (传输层)
职责:
- 底层网络IO
- 异步数据传输
- 连接建立/断开

特点:
- 高性能异步IO
- 系统级网络接口
